#Colifrapy 0.3.0

##Description
Colifrapy is a Command Line Framework for Python.
Its aim is to provide several tools to build robust and
structured command line tools very easily.

Its logic is very similar to a MVC framework and is therefore easy to use.

##Installation
It is recommanded to use colifrapy under a python virtualenv.

Install it with pip :

```
pip install colifrapy
```

##Philosophy
The goal of colifrapy is to load a yaml configuration file managing 
several settings such as your command line arguments,
version name and, if needed, your contextual settings.

Once those settings are loaded, you can call upon colifrapy models to do the
work while remaining able to access critical utilities such as argv opts, settings 
and logger.

##Usage

###Scaffolding
Colifrapy is able to create a new blank project for you.

```sh
colifrapy new [project]

# Options
-a/--author [name] : name of the project's author
```

This will create the necessary files to start working immediatly. I.e. a command line hub, a base
controller, an example model, a config file and a string file.

To test if the scaffolding has worked :
```sh
cd [project]
python [project].py test
```

It should output a header displaying your project's title and a short line telling you it's fine.

###Command Line Hub
A colifrapy project relies on a command line hub which extends Colifrapy base class and which can
be called from the root of your project. The duty of this hub is just to launch your tool, analyze
the arguments given to it and call upon the relevant controller methods.

In fact, this hub can be compared to a router for web frameworks.

This is the hub as it will be generated by the scaffolder :

```python
# Dependencies
#=============
from colifrapy import Colifrapy
from model.controller import Controller

# Hub
#======
class NameOfYourProject(Colifrapy):
    
    # From this hub, you can access several things :
	#    self.settings (Settings Instance)
	#    self.log (Logger Instance)
	#    self.opts (Options passed to your hub)
	#    self.controller (Your Controller)

    def launch(self):

        # Welcoming visitors
        self.log.header('main:title')

        # Calling upon the controller
        self.controller.test()

# Launching
#===========
if __name__ == '__main__':
	# By default, the hub will load config/settings.yml
    hub = NameOfYourProject(Controller, [optional]'path/to/your/settings.yml')
    hub.launch()
```

###Controller
The controller (which is totally optionnal, if you don't want to follow this logic, just don't pass a controller to your hub instance), is a class that will call upon your models to perform actions. (The controller is in fact a colifrapy Model instance, but this must not disturb you).

###Settings
The Settings class is the first class loaded by colifrapy to perform its magic. It will parse your settings.yml file and configure your logger, arguments and every other configuration you want for your application.

config/settings.yml file:

```yaml
# Basic Informations
version: '[project-name] 0.1.0'
description: 'Description of the program.'
arguments: 
- [ ['-t', '--test'], {'help' : 'Test', 'type' : 'int'} ]
- [ ['positionnal'] ]

# Logger Settings
logger:
    strings: 'config/strings.yml'
    flavor: 'default'
    title_default: 'default'
    # Delete the path line not to write the log to a file
    path: 'logs'
    threshold: ['DEBUG', 'ERROR', 'INFO', 'WARNING', 'VERBOSE']

# Generic Settings needed by your program
settings:
    hello: 'world'
    bonjour: 3.4
    hash: {'test' : 2}
```

The settings are loaded automatically by colifrapy but you still can use its logic elsewhere if
you need it. 

An example of external use :

```python
# Importing
from colifrapy import Settings

# Loading settings
settings = Settings()

# Let the path blank to fetch 'config/settings.yml' by default
settings.load('path/to/your/settings.yml')

# Now use it
print settings.hello
>>> 'world'

print settings.hash['test']
>>> 2
```

The Settings class is a singleton. You can therefore use it everywhere without having to reload the data.

###Command and Arguments
Arguments are to be defined as for the python [ArgParser](http://docs.python.org/dev/library/argparse.html "ArgParser") class.

Examples of argument declaration:
```yaml
arguments: 
- [ ['-t', '--test'], {'help' : 'Test', 'type' : 'int', 'default' : 5} ]
- [ ['-b', '--blue'], {'help' : 'Blue option', 'type' : 'int', 'required' : 'True'} ]
- [ ['some_positionnal_argument'] ]
```

Once the settings are loaded, you can access your options through:
```python
from colifrapy import Commander
command = Commander()

print command.opts.test
>>> 5
```
As for the Settings class, the Commander class is a singleton and its state won't change if you load it elsewhere.

If the command hub and in your models, you can access the options passed to your commander through
self.opts . However, even if those are accessible in models for commodity, only the main hub should use them and one should restrain their usage in models.

###Model
Models are the bulk of Colifrapy. You can extend them to acces your settings and commands easily.

An example model is generated for you by the Scaffolder when you create a new project.

Example:
```python
from colifrapy import Model

class MyModel(Model):
	def test(self):
		print self.settings.hello

m = MyModel()
m.test()
>>> 'world'
```

Reserved attributes names are:

	log (access to the logger described right after)
	opts (access to the command line options)
	settings (access to the program's settings)


###Logger and strings
The logger is the outputting class of colifrapy. It should be loaded with some strings by the settings.
If no strings are given, the logger will just output normally the argument string you give it.

The logger accepts five levels :

	INFO (green output)
	VERBOSE (cyan output)
	DEBUG (blue output)
	WARNING (yellow ouput)
	ERROR (red output) --> will throw an exception for you to catch or not

By default, if no level is specified for a message, DEBUG will always be taken.

The fact that strings are externalized permits you to quickly modify the strings if
needed ,or even translate them easily.

The string format used is in fact [Mustache](http://mustache.github.io/), so variables
come likewise : {{some_variable}}

Strings given must follow this yaml layout:
```yaml
main:
    process:
    	# String with a variable contained within the mustaches
        start: 'Starting corpus analysis (path : {{path}})//INFO'
        # Simply write two slashes at the end to specify the level of the message
        end: 'Exiting//ERROR'
        test_line_break: '\nBonjour'
    title: 'Colifrapy'
other_string_category:
	test: 'Hello everyone//INFO'
	you:
		can:
			make: 'any levels that you want'
			so: 'you can organize your strings however you need.'
```
And this is how you use the logger:
```python
from colifrapy import Model

class MyModel(Model):
	def test(self):

		# Main method
		#------------

		# Outputting a message
		self.log.write('main:process:end')
		>>> [ERROR] :: Exiting

		# Overriding the message level
		self.log.write('main:process:end', 'INFO')
		>>> [INFO] :: Exiting

		# Passing variables
		self.log.write('main:protocol:start', {'path' : 'test'})
		>>> [INFO] :: Starting corpus analysis (path : test)

		# Wrong message if yml file specified
		self.log.write('main:wrong_message')
		>>> Exception Colifrapy::Logger::WrongMessage

		# When yml file is not specified
		self.log.write('Test string', level='DEBUG')
		>>> [DEBUG] :: Test string

		# Arguments of write
		variables --> hash
		level --> log level

		# Helper methods
		#---------------

		# Printing a header (yellow color)
		self.log.header('main:title', [optional]color)
		>>> Colifrapy
		>>> ---------

		# Write methods shorteners
		self.log.error(message, vars)
		self.log.warning(...)
		self.log.info(...)
		self.log.debug(...)
		self.log.verbose(...)
```

You can pass some options to your logger within the settings.yml file.

Example:
```yaml
# Logger settings
logger:
	strings: 'path/to/your/strings.yml'

	# optional, discard the line not to log to a file
	path: 'path/where/to/log/'

	# optional, use it to specify your logger threshold
	# ERROR will always be kept whatsoever for obvious reasons, even if you drop it
	log_threshold : ['DEBUG', 'ERROR']
	
	# optional (default, False), whether you want your errors to raise exceptions
	exceptions: False

	# flavors (see Eyecandy) you can drop those lines if you want default
	flavor: 'default'
	title_flavor: 'default'
```

The Logger is also a singleton, you can use it as a standalone, if you need to :

```python
from colifrapy import Logger

log = Logger()

# If you haven't configured it before in your code and you use it outside colifrapy
# Pass kwargs to it corresponding to the logger options in settings.yml
log.config(**kwargs)

log.debug('test')
>> [DEBUG] :: test
```

###Eye Candy
Colifrapy comes with visual alternatives (two for the moment, but more will come). They are called 
'flavors' and can be set in the Logger's settings.

Flavors :

```
# Title Flavors:

'default'

Title
-----

'heavy'

#########
# Title #
#########


# Logger Flavors:

'default'

[DEBUG] :: text

'flat'

debug : test
```

###Bonus
Colifrapy also gives access to a color class, a custom exception class and a basic singleton decorator if needed.

```python
from colifrapy.tools.colorize import colorize
print colorize('hello', 'blue')

from colifrapy.tools.decorators import singleton

@singleton
class MySingleton():
	pass

# Custom Exception Carrying data
from colifrapy import DataException
raise DataException(message, data)
```

##Examples
My project [furuikeya](https://github.com/Yomguithereal/furuikeya) is a good example of the usage
of colifrapy since colifrapy was originally designed to help me doing it.

##Dependancies

	pyyaml
	pystache

##License
Colifrapy is under a MIT license.